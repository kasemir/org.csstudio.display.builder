<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
  <title>Display Builder</title>
  <link rel="stylesheet" href="PLUGINS_ROOT/PRODUCT_PLUGIN/book.css" type="text/css"></link>
  <link rel="stylesheet" href="section_numbers.css" type="text/css"></link>
  <style>
	  table {
		  border: 1px solid black;
	  }
	  th {
		  padding: 6px;
		  text-align: center;
		  border-bottom: 1px solid #777;
	  }
	  td {
		  padding: 6px;
		  text-align: left;
		  border-bottom: 1px solid #ddd;
	  }
  </style>
</head>
<body>

<!-- Aiming for one long file to allow printing of the complete 'manual'.

     Exception: javadoc API
  -->

<h1>Display Builder</h1>

<b>Table of Contents</b>

<!-- Topics are duplicated in toc.xml -->

<ol>
<li><a href="#overview">Overview</a></li>
<li><a href="#get_started">Getting Started</a></li>
<li><a href="#editor">Display Editor</a></li>
<li><a href="#conversion">BOY <i>*.opi</i> File Conversion</a></li>
<li><a href="#classes">Widget Classes</a></li>
<li><a href="#runtime">Display Builder Runtime</a></li>
<li><a href="#perspective">Display Runtime Perspective, Full-screen, Standalone</a></li>
<li><a href="#widgets">Widgets</a></li>
<li><a href="#properties">Properties</a></li>
<li><a href="#rules">Rules</a></li>
<li><a href="#scripts">Scripts</a></li>
</ol>

<!-- ====================================================== -->
<h2><a name="overview">Overview</a></h2>
<!-- ====================================================== -->

<p>The Display Builder is a panel editor and runtime for control system displays.
</p>


<h2><a name="get_started">Getting Started</a></h2>

<h3>Display Builder Examples</h3>

<p>The Display Builder example files demonstrate many of its widgets and features.
</p>

<center>
	<img src="images/GettingStarted_samples1.png" alt="CS-Studio > Utilities > Install Samples" width="400" style="vertical-align:top;padding-right:16px"/>
	<img src="images/GettingStarted_samples2.png" alt="X/Y Plot Widget example" width="400" style="vertical-align:top"/>
</center>

<p>Open the menu <b>CS-Studio</b> > <b>Utilities</b> > <b>Install Samples</b>.
Select <i>Display Builder</i> and click OK.
The examples will be in a project folder named "Display Builder".
</p>

<p>Start the first example display, <b>01_main.bob</b>, by right-clicking on the file in the Navigator and selecting
<b>Open With...</b> > <b>Display Runtime</b>.
</p>


<!-- ====================================================== -->
<h2><a name="editor">Display Editor</a></h2>
<!-- ====================================================== -->

<p>You use the Display Editor to create new display files or to modify existing display files.
</p>

<h3>Display Editor Perspective</h3>

<p>The Display Editor perspective offers the tools and settings needed to edit
Display Builder (*.bob) files.
From CS-Studio, the Display Editor perspective
can be opened from the menu bar: <b>Window</b> > <b>Open Perspective</b> > <b>Other...</b>,
then select <b>Display Editor</b>.
</p>

<p>Alternatively, if you are already inside the display editor,
right-click in the central Editor part and select <b>Open Editor Perspective</b>.
This will open the Display Editor perspective,
or - in case are already in that perspective -
a dialog will ask if you want to reset the perspective to its default layout.
</p>


<h3>Creating a New Display</h3>

<p>From within the Display Editor perspective, right-click on a project in the Navigator and select
<b>New</b> > <b>New Display</b>.
This will open the New Display wizard where you enter the name of your new display file.
</p>

<p>Alternatively, you can use the menu
<b>File</b> > <b>New...</b>, and under <i>Display Editor</i>, select <b>New Display</b>.
Then choose a container and name for the new display file in the New Display wizard.
</p>

<h3>Editing an Existing Display</h3>

<p>Right-click on a <i>*.bob</i> or <i>*.opi</i> file in the Navigator and select
<b>Open With...</b> > <b>Display Editor</b> (or <b>Other</b> > <b>Display Editor</b>).
</p>

<p>If you are already executing a display, you can open that display file in the editor
by right-clicking anywhere in the display runtime and selecting <b>Open in Editor</b>.
</p>

<h3>Executing a display from the Editor</h3>

<p>Right-click anywhere in the editor pane and select <b>Execute Display</b>
to start a Display Runtime for the file.
This will automatically save the file, so any pending changes
will be written to the *.bob file.
</p>

<h3>Adding Widgets</h3>

<p>There are two fundamental ways of adding widgets to a display:
</p>

<ul>
<li>Select widget in Palette and "Rubberband" the desired location:<br/>
    Click on a widget type in the <em>Widget Palette</em>,
    then draw a "Rubberband" type rectangle in the editor,
    i.e. click the left mouse button where the top-left corner
    of the new widget should be.
    Keeping the left mouse button depressed,
    drag the mouse to the desired bottom-right corner of the new widget.
    Release the mouse button to create the new widget in the
    desired location with the desired size.
</li>
<li>Drag a widget from the Palette:<br/>
    Click on a widget type in the <em>Widget Palette</em>,
    and drag it, keeping the left mouse button depressed,
    into the editor.
    As soon as the mouse button is released,
    the widget is added to the editor.

    <strong>Note:</strong> While dragging the widget,
    the dragging outline image is not displayed on all platforms
    because of a known issue in the FXCanvas class on Java 8. It will be solved in the
    upcoming Java 9 release.
</li>
</ul>

<p>
Either way you add a widget, if the <em>Align widgets to Grid</em> option is selected in the toolbar,
the new widget location will snap to the closest grid position.
</p>
<p>
The newly added widget will be automatically selected,
allowing you to quickly move or resize it as described below.
</p>

<img src="images/DragAndDrop_adding_widget.png" alt="Adding widgets from Widget Palette." style="float:right;margin:0 0 0px 8px;"/>

<h3>Editing Widgets</h3>

<p>Most of the editing is performed dragging things around:</p>
<ul>
	<li>Add widgets dragging them from the <em>Widget Palette</em> into the editor as described above,</li>
	<li>select one or more widgets by "rubber banding" around them,</li>
	<li>move selected widgets,</li>
	<li>resize selected widgets,</li>
	<li>add text, images or files by dragging it from outside into the editor.</li>
</ul>


<h4 style="clear:right">Selecting Widgets</h4>

<p>
The easiest way to select a single widget is by clicking on it.
De-select it by clicking it again, or by clicking on the background
of the display where there is no widget.
</p>
<p>
To select multiple widgets, hold the 'Control' key
and then click on widgets to add them to the selection.
To de-select one widget from a multi-widget selection,
hold the 'Control' key and then click
on an already selected widget.
</p>


<h4>Rubber Band Selection</h4>

<p>
The easiest way to select multiple nearby widgets is by rubber banding around it.
Click on the editor's background and, while keeping the mouse button depressed,
drag until the dashed rubber band encloses all the widgets of interest.
When you release the mouse button,
the selected widgets will be surrounded by the selection outline.
</p>

<p>
Once one or more widgets are selected, they can be moved and resized as a single entity,
as explained in the following paragraphs.
In addition, the properties of all selected widgets can be adjusted in the
<a href="#properties">Properties Panel</a>.
</p>

<center>
	<img src="images/DragAndDrop_rubber_band_selection.png" alt="Rubber band selection." width="600"/>
</center>



<h4>Moving Widgets</h4>

<img src="images/DragAndDrop_moving.png" alt="Moving a widget." style="float:right;margin:0 0 0px 8px;"/>

<p>
	Once widgets are selected, it is possible to move them around by clicking inside the selection
	outline and dragging. The selection outline will follow the cursor movements until the
	mouse button will be released, and the widgets will be actually moved.
</p>

<p>
	If the
	<img src="PLUGINS_ROOT/org.csstudio.display.builder.editor/icons/grid.png"/>
	<em>Align widgets to Grid</em> button is selected, then the selection outline
	will align to grid points when moving.
</p>

<p>
	If the
	<img src="PLUGINS_ROOT/org.csstudio.display.builder.editor/icons/snap.png"/>
    <em>Snap to widgets</em> button is selected, then the selection outline
	will align to existing widgets' edges when moving, displaying a cyan alignment ruler.
</p>

<p>
    If the
    <img src="PLUGINS_ROOT/org.csstudio.display.builder.editor/icons/coords.png"/>
    <em>Widget Coordinates</em> button is selected, and the selection outline is
    large enough to accomodate the additional information,
    selection outline will indicate the location and size.
</p>

<p>
    If the
    <em>Shift Key</em> is held while moving the selected widgets,
    the move is restricted to a horizontal or vertical move.
</p>


<h4 style="clear:right">Resizing Widgets</h4>

<img src="images/DragAndDrop_resizing.png" alt="Resizing a widget." style="float:right;margin:0 0 0px 8px;"/>

<p>
	Once widgets are selected, it is possible to resize them by clicking inside one of the
	selection outline's handles and dragging. The selection outline will follow the cursor
	movements until the mouse button will be released, and the widgets will be actually resized.
</p>

<p>
    The
    <img src="PLUGINS_ROOT/org.csstudio.display.builder.editor/icons/grid.png"/>
	<em>Align widgets to Grid</em>,
	<img src="PLUGINS_ROOT/org.csstudio.display.builder.editor/icons/snap.png"/>
	<em>Snap to widgets</em>
	and
    <img src="PLUGINS_ROOT/org.csstudio.display.builder.editor/icons/coords.png"/>
    <em>Widget Coordinates</em> buttons again control if the resized region
    snaps to grid coordinates or other widgets,
    optionally displaying the location and size.
</p>

<h4 style="clear:right">D &amp; D From Outside</h4>

<p>
	Different entities dragged from outside the editor can be dropped in. When the nature
	of these entities is compatible, the editor will accept the drag an drop operation
	creating a series of widgets.
</p>

<h4>Dropping Images</h4>

<p>
	An image (possibly dragged from a web browser) can be dropped into the editor.
	That image will be saved into a temporary location and Picture widget will be
	created pointing the the saved image file.
</p>

<p>
	<strong>Note:</strong> The created Picture widget will have its top-left
	corner at the location (possibly snapped to grid) wher the cursor was when
	the image was dropped.
</p>

<p>
	The created widget will be automatically sized the to dropped image size.
</p>

<center>
	<img src="images/DragAndDrop_image_drag.png" alt="Image drag." width="400" style="vertical-align:middle;padding-right:8px"/>
	<font size="32">&#10143;</font>
	<img src="images/DragAndDrop_image_drop.png" alt="Image drop." width="400" style="vertical-align:middle;padding-left:8px"/>
</center>

<h4>Dropping Files</h4>

<p>
	Image files (with extension <code>.bmp</code>, <code>.gif</code>, <code>.jpeg</code>,
	<code>.jpg</code>, <code>.png</code>, and <code>.svg</code>) and OPI files (with extension
	<code>.bob</code>, and <code>.opi</code>) can be dropped into the editor.
	A single image file will create Picture widgets. Multiple image files will create a
	Symbol widget, while OPI files will create
	Embedded Display ones. The created widget will reference the dropped file,
	using (if possible) a relative path location.
</p>

<p>
	Multiple files can be dropped at once. Each one will create its own corresponding
	widget (Picture or Embedded Display), that will be offset by a grid step in
	both coordinates from the preceeding one.
</p>

<h4 style="clear:right">Dropping URLs</h4>

<p>
	When dropping a URL into the editor, one of the following situations occurs:
</p>

<ul>
	<li>
		The URL string ends with one of the supported image extensions (<code>.bmp</code>,
		<code>.gif</code>, <code>.jpeg</code>, <code>.jpg</code>, and <code>.png</code>),
		then a Picture widget will be created and positioned under the (possibly aligned
		to grid) cursor position;
	</li>
	<li>
		The URL string ends with one of the supported OPI extensions (<code>.bob</code>,
		and <code>.opi</code>), then an Embedded Display widget will be created and
		positioned under the (possibly aligned to grid) cursor position;
	</li>
	<li>
		Otherwise a dialog will open allowing the user to chose the widget to be
		created.
	</li>
</ul>

<center>
	<img src="images/DragAndDrop_url.png" alt="Dropping an URL."/>
</center>

<h4>Dropping Text</h4>

<p>
	Text may be composed of a single or multiple lines. Each line could be
	interpreted as a PV name. For this reason a dialog will open allowing to select
	a single Label widget (displaying the whole text), multiple Label Widgets
	(displaying a line each), or multiple widgets (of the same type) using each
	line as a PV name.
</p>

<p>
	Multiple widgets will be offset by a grid step in booth coordinates from the
	preceding one.
</p>

<center>
	<img src="images/DragAndDrop_text1.png" alt="Text drag." width="200" style="vertical-align:middle;padding-right:8px"/>
	<font size="32">&#10143;</font>
	<img src="images/DragAndDrop_text2.png" alt="Text drop." width="300" style="vertical-align:middle;padding-left:8px"/>
	<font size="32">&#10143;</font>
	<img src="images/DragAndDrop_text3.png" alt="Widgets created." width="300" style="vertical-align:middle;padding-left:8px"/>
</center>





<!-- ====================================================== -->
<h2 style="clear:right"><a name="conversion">BOY <i>*.opi</i> File Conversion</a></h2>
<!-- ====================================================== -->

<p>The Display builder automatically convert BOY <i>*.opi</i> files.
Whenever you open a <i>*.opi</i> file, the Display Builder maps all legacy widgets
to the new widgets and their corresponding properties.
</p>

<p>In many cases, existing <i>*.opi</i> require no changes at all to execute properly
in the Display Builder runtime.
This means you can simply select an existing <i>*.opi</i> file
in the Navigator and use the <b>Open With...</b> > <b>Display Runtime</b> context menu
to execute the display.
Likewise, actions that open related displays in legacy <i>*.opi</i> file format
will automatically load, convert and execute those.
</p>

<p>Sometimes, you may want to slightly rearrange widgets to look better
in the Display Runtime.
In rare cases, you will have to edit the file because widget behavior has changed.
Also beware that most <a href="#scripts">scripts</a> associated with the display need to be updated.
Scripts are the most likely cause of failures in converted files.
Finally, you might simply want to change the display to get new behavior.
</p>

<p>To edit, simply right-click on any <i>*.opi</i> file in the Navigator and use
<b>Open With...</b> > <b>Display Editor</b> to load the legacy file into the Display Builder editor.
If you are already executing the file in the Display Builder runtime,
use the context menu to <b>Open in Editor</b>.
You can now edit the file.
When saving the file, the file name is changed to <i>*.bob</i>.
</p>

<h3>Transition Hints</h3>

<p>Whenever the Display Builder is asked to open a <i>*.opi</i> file,
it will check for an alternate <i>*.bob</i> file.
</p>

<p>To transition from BOY to the Display Builder, it is thus best
to start with the existing <i>*.opi</i> files.
For those files that need to be adjusted,
edit the <i>*.opi</i> file and save it as a new <i>*.bob</i> file,
but keep the previous <i>*.opi</i> file.
This way, BOY can still be used with the existing files,
while the Display Builder will select the converted files,
and both tools can thus be used in parallel until all
files that need adjustments have been updated.
</p>

<p>If the only change required in a <i>*.opi</i> file
relates to a script, that script can be made bilingual
by following the Display Builder <a href="#get_started">example</a>
from <i>Display Builder/script_util/porting.opi</i> and
<i>Display Builder/script_util/portable.py</i>.
</p>



<!-- ====================================================== -->
<h2><a name="classes">Widget Classes</a></h2>
<!-- ====================================================== -->

<h3>Defining Widget Classes</h3>

<p>Create a new display file via <b>New</b> > <b>New Display</b>,
but enter a file name like "classes.bcf" that ends in <b>*.bcf</b>
instead of the usual "*.bob" to create a class file.
</p>

<p>When the display editor is used for class files,
each property of a widget has a check box next to it
to mark this property as being included in the class definition.
For example, drag a <b>Label</b> widget from the palette
into the editor.
Set its name to TITLE.
Then check the x, y, font, color and transparent properties
and set them as shown in the screenshot.
</p>

<img src="images/class_def.png"/>

<p>This defines a "TITLE" class for labels:
Its position is always in the upper left corner of the display (x and y set to 0).
It uses a certain font and colors.
</p>


<h3>Using Widget Classes</h3>

<p>Open the menu <b>Edit</b> > <b>Preferences</b> to locate the Display Builder settings.
Note the "Widget Class Files:" setting which allows for a list of class files,
separating multiple entries with a semicolon.
The class files are loaded when the display builder starts for the first time.
They are re-loaded whenever you save a class file,
or via the <b>Re-load Widget Classes</b> context menu of the display file editor.
</p>

<p>When you now open the display editor to create a new display,
i.e. a "*.bob" file and add a label to the display,
note that the "class" property has a drop-down list that includes
"TITLE" as a known class name.
Selecting "TITLE" will apply the x, y, font, color and transparent
settings that were defined in the class.
Furthermore, these properties are marked with a
<img src="PLUGINS_ROOT/org.csstudio.display.builder.editor/icons/class_property.png"/>
in the property panel, they cannot be modified.
</p>

<img src="images/class_use.png"/>

<p>The display is saved with all the settings of the widget,
including those that were provided by the class.
Whenever a display is executed in the display builder runtime,
the current class settings are applied.
If the current class files don't define a "TITLE" class for labels,
the display will appear as it was last saved.
If the current class files do define a "TITLE" class for labels,
those will be applied, meaning you can update
the class definition files and those new settings will then
be applied when a display is executed.
</p>

<!-- ====================================================== -->
<h2><a name="runtime">Display Builder Runtime</a></h2>
<!-- ====================================================== -->

<h3>Display Builder Runtime</h3>

<p>When you execute a display, the Display Builder runtime
opens the <i>*.bob</i> (or legacy <i>*.opi</i>) file,
connects to process variables, displays their value in Text Update widgets etc.
</p>

<p>When you right-click on a widget,
the first entry in the context menu which shows the name of the widget
opens an information panel for the widget.
Additional entries allow saving a snapshot of the display,
or to re-load the display.
</p>


<!-- ====================================================== -->
<h2><a name="perspective">Display Runtime Perspective, Full-screen, Standalone</a></h2>
<!-- ====================================================== -->

<h3>Display Runtime Perspective</h3>

<p>The Display Runtime Perspective is initially empty, meant to display runtime panels.
</p>

<p>For a production setup,
use the Display Builder "Top Displays" preference to configure a list of top level displays,
i.e. starting points for your users.
</p>

<p>Then open the Display Runtime Perspective, and use either the menu
<b>File</b> > <b>Top Displays</b>
or the Top Displays drop-down button in the tool bar to open these
from within the Display Runtime Perspective.
Display runtime panels can then be arranged by dragging their title tabs
into the desired location.
</p>

<p>Typically, at least one such Display Runtime Perspective with a pre-arranged
displays layout is then saved as a named Perspective
and used as a default layout.
</p>


<h3>Full-screen Mode</h3>

<p>The <b>Full-screen</b> entry in the runtime panel context menu
allows toggling the workbench window into and out of full-screen mode.
In full-screen mode, the menu, toolbar and status bar are hidden to
maximize the area available for display runtimes.
Only the title tabs of each display are still shown.
Exact details depend on the operating system.
For Mac OS X, the menu bar is hidden but remains accessible when moving the
mouse to the top of the screen. On Linux, the menu is turned off.
If supported by the operating system, the full-screen mode selects
a window mode in which the window becomes the only visible window
on the monitor, always on top of all other windows on that computer display.
</p>

<p>To exit full-screen mode and restore the menu, toolbar and status bar,
invoke the <b>Exit Full-screen</b> entry in the runtime panel context menu.
</p>


<h3>Standalone Window Mode</h3>

<p>Selecting <b>Change to Standalone Window</b> from the runtime panel context menu
closes the display runtime panel in the workbench window and instead opens
that runtime as a plain standalone window.
</p>

<p>Advantage:</p>
<ul>
<li>Minimal visual decorations. No toolbar, no perspective switcher, no display title tab.
    Maximum space for display
</li>
<li>Slightly faster display updates because of top-level JavaFX window, not embedded in SWT</li>
</ul>

<p>Disadvantage:</p>
<ul>
<li>No context menu to inspect widgets, email screenshot etc.</li>
<li>No toolbar to navigate back to the previous display or to zoom in/out.</li>
<li>Cannot 'save' layout in context of Perspective</li>
<li>No way to re-attach standalone window to workbench</li>
</ul>


<!-- ====================================================== -->
<h2><a name="widgets">Widgets</a></h2>
<!-- ====================================================== -->

<p>Widgets are the components of Display Builder displays.
In the editor, you add Widgets to the display by dragging them
from the Widget Palette into the editor.
Then you typically adjust the location and size,
and enter a text or PV name by configuring the corresponding property.
</p>

<p>The following is a brief description of core widgets.
For details on each widget refer to the
<a href="#get_started">example displays.</a>
They showcase each widget and explain their key properties.
</p>

<h3>Graphic Widgets</h3>
<!-- ============== -->

<p>These widgets represent static content.</p>

<h4>Label Widget</h4>
<!-- ^^^^^^^^^^^^^ -->

<p>One or more lines of text.
Use to create labels or descriptions.
</p>


<h4>Arc, Ellipse, Rectangle, Polygon, Polyline Widget</h4>
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->

<p>Graphic elements for creating basic diagrams.</p>

<p>For Polygon and Polyline refer to example display
to learn about editor support for creating and modifying
the points of a polygon/line.
</p>


<h4>Picture Widget</h4>
<!-- ^^^^^^^^^^^^^^^ -->

<p>Widget for adding images (PNG, GIF, ..) to the display.</p>


<h3>Monitor Widgets</h3>
<!-- ============== -->

<p>These widgets show the current value of a PV.</p>

<h4>Text Update Widget</h4>
<!-- ^^^^^^^^^^^^^^^^ -->

<p>Main widget for displaying the current value of a PV.</p>

<h4>Byte Monitor, LED, Progress bar, Tank, Thermometer Widget</h4>
<!-- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -->

<p>Widgets that display the current value of a PV in a graphical way.</p>


<h3>Control Widgets</h3>
<!-- ================= -->

<p>These widgets allow you to change the value of a PV.</p>

<h3>Plot Widgets</h3>
<!-- ============== -->

<p>These widgets create plot, typically requiring waveforms or multiple PVs.</p>


<h3>Structure Widgets</h3>
<!-- ============== -->

<p>These widgets structure several basic widgets or complete displays witnin a display.</p>

<h4>Group Widget</h4>
<!-- ^^^^^^^^^^^ -->

<p>Groups several basic widgets, by default adding a labelled border around them.</p>


<h4>Embedded Display Widget</h4>
<!-- ^^^^^^^^^^^^^^^^^^^^ -->

<p>Includes another display within the current display.
The embedded display is usually a smaller, re-usable display
that utilized macros instead of complete PV names.
The embedded display widget can then include that sub-display
with suitable macros.
</p>


<!-- ====================================================== -->
<h2><a name="properties">Properties</a></h2>
<!-- ====================================================== -->

<img src="images/tracker.png" alt="Tracker" style="float:right;margin:0 0 0px 8px;"/>

<p>Every widget has properties <b>x</b>, <b>y</b>, <b>width</b> and <b>height</b>
that define its position and size within the display.
While these properties can be entered in the Properties View,
a widget can also be moved interactively by moving the selected widget
in the editor with the mouse,
and the size can be changed by moving the square handles in the corner of the selected widget with the mouse.
</p>

<p><b>Label</b> widgets have a <b>text</b> property for configuring the text
shown in the label.
Many widgets have a <b>pv_name</b> property for configuring the name of the
PV that the widget will display or control at runtime.
These key properties can be edited by double-clicking the selected widget
and then entering the text or pv_name.
</p>

<h3 style="clear:right">Properties View</h3>

<img src="images/properties_palette.png" alt="Properties View" style="float:right;margin:0 0 0px 8px;"/>

<p>In general, properties are edited in the <b>Properties View</b>.
It lists every property of a widget with its current value,
and except for very few static properties it allows entering or selecting different values.
</p>

<h3>Property Names</h3>

<p>The "Properties" panel will show each property with a description like "X Position", "Text" or "PV Name".
This is the localized description of each property which might be different in for example a German version of the Display Builder.
Each property also has a unique name that is used in the <i>*.bob</i> file
or when accessing a property from a <a href="#rules">rule</a> or <a href="#scripts">script</a>.
The name of a property is typically based on the simplified English description, all lower case:
<b>x</b>, <b>text</b>, <b>pv_name</b>.
</p>

<p>The Property View shows the underlying name of each property in a tool tip
that appears when you hover the mouse over the property description.
In the following description of properties, we always use the property name.
</p>


<h3>Common Properties</h3>

<h4>type</h4>

<p>Type of widget (e.g. label, text_update). Each widget has both a localizable (translatable)
type name and an internal type name used to identify the widget type in display files.
</p>

<h4>name</h4>

<p>Used to identify the widget. Is best made unique within the display.
</p>

<h4>x, y, width, height</h4>

<p>Location and size of the widget.
Can be configured in the Property view, but are typically adjusted using the
mouse on the selected widget.
</p>

<h4>text</h4>

<p>Text that a Label widget displays. Can also be configured via double-click on the widget.
</p>

<h4>pv_name</h4>

<p>The PV that the widget uses to read or write values. Can also be configured via double-click on the widget.
</p>

<h4>actions</h4>

<p>Attach Actions that do things like open displays or run scripts.
Primarily used with the <b>Action Button</b> widget.
</p>

<h4>text</h4>

<p>Text that is displayed in a <b>Label</b> widget or used
as the title of a <b>Group</b> widget.
</p>

<h4>pv_name</h4>

<p>All but the plain Graphics widget have at least one PV name.
At runtime, the widget connects to this PV, displays its current value,
and in the case of Control widgets also writes to it when you interact with the widget.
</p>

<h4>format, precision</h4>

<p>Text-based widgets have several formatting options for displaying the current value of a PV.
For formats that use the <b>precision</b>, a precision of -1 uses the precision
provided by the PV.
</p>

<ul>
<li><b>Default:</b>
    Show a number as a decimal, an enumerated value via its label, and text as text.
</li>
<li><b>Decimal</b>
    Show numeric and enumerated values as a decimal like "3.14"
    <b>Precision</b> determines the number of digits after the decimal points, 2 in this example.
</li>
<li><b>Exponential:</b>
    Show numeric values in exponential notation like 3.14E0.
    <b>Precision</b> determines the number of digits after the decimal points, 2 in this example.
</li>
<li><b>Engineering:</b>
    Similar to exponential notation but always using an exponent
    that is a multiple of 3 to correspond to the common orders-of-magnitude
    'micro', 'milli', 'kilo', 'mega' etc.
    The number 31400 would be displayed as "31.4000E3" when using a precision of 4.
</li>
<li><b>Hexadecimal:</b>
    Shows 255 as "0xFF". Truncates all numbers to integers.
</li>
<li><b>Compact:</b>
    Formats numbers within the range of 0.0001 to 10000 as decimal,
    otherwise uses exponential notation.
    Typically results in the shortest representation.
</li>
<li><b>String:</b>
    Text is displayed as provided.
    Byte arrays are converted to text using UTF-8 encoding.
</li>
<li><b>Sexagesimal:</b>
    Shows number as degrees or hours, minutes, and seconds with colons between the three fields.
    The integer part of the number determines the hours respectively degrees.
    The fractional part is expressed as minutes and seconds plus fractions of a second.
    For example, "12:45:10.2", is the number 12.752833 expressed as 12 degrees or hours, 45 minutes, and 10.2 seconds.
    The <b>precision</b> determines the number of digits after the first colon.
    For precisions of 0, 1, 2, 3, 4, 5, and 6 the number above would be expressed as
    13, 12:5, 12:45, 12:45:1, 12:45:10, 12:45:10.2, and 12:45:10.20, respectively.
</li>
<li><b>Sexagesimal DMS:</b>
    Similar to sexagesimal, but assuming that the number is in radians
    and 2&pi; represent 360 degrees.
    When displaying a number, it is converted to degrees by multiplying it by 180/&pi; before formatting it.
    When parsing DMS, the result is divided by 180/&pi; to convert degrees into radians.
    <i>(If you ever actually use this option, please let me know!)</i>
</li>
<li><b>Sexagesimal HMS:</b>
    Similar to sexagesimal, but assuming that the number is in radians
    and 2&pi; represent 24 hours.
    When displaying a number, it is converted to degrees by multiplying it by 12/&pi; before formatting it.
    When parsing HMS, the result is divided by 12/&pi; to convert hours into radians.
    <i>(Same here, let me know!)</i>
</li>
</ul>

<h4>rules</h4>

<p>Each widget has several additional properties that for example allow the configuration
of colors, the formatting of texts etc.
Ideally, you can create a functional control system display by configuring the basic
properties of a widget, relying on the default behavior of a widget.
For special cases, widgets can use <a href="#rules">Rules</a> that dynamically
assign widget property values based on conditional expressions.
</p>

<h4>scripts</h4>

<p>Similar to Rules but even more flexible are <a href="#scripts">Scripts</a>
that dynamically control widget appearance and behavior.
</p>


<h3>Array and Structure Properties</h3>

<p>Some widgets contain properties that are arrays and/or structures.
For example, the <b>Multi-State LED</b> has a <b>states</b> property that is an array.
The elements of the array are in turn structures with a <b>value</b> and a <b>color</b>.
For access from Rules or Scripts these properties can be accessed via names (for structured
properties) and indices (for array properties).
Example:
</p>
<pre>states[0].value</pre>
<pre>states[1].color</pre>

<!-- ====================================================== -->
<h2><a name="rules">Rules</a></h2>
<!-- ====================================================== -->

<p>Rules are the suggested way to obtain customized, dynamic behaviors beyond the capability of
<a href="#properties">widget properties</a> alone.
The alternative to rules are <a href="#scripts">scripts</a>.
Rules are recommended over scripts. While rules are more limited than scripts,
their API is expected to remain stable as the Display Builder evolves.
Scripts on the other hand are very likely to require adjustments
when updating to a new version of the Display Builder.
</p>

<p>Unlike scripts, rules require no code aside from simple expressions. Rules set widget property
values according to boolean expressions using their input PVs. Since the execution of a rule is
triggered by its trigger PVs, at least one input PV is needed for a rule.
</p>

<h3>Attaching a Rule to a Widget</h3>
<p>In order to edit the Rules for a widget, first select it, then click on the button
for its Rules property in the Properties palette. This will open the Rules dialog.
</p>

<center>
	<img src="images/Rules.png" alt="Rules Dialog" style="height:456px;"/>
</center>

<p>
In the example shown in the screenshot, a rule named "New Rule" sets the "text" property of a Label widget.
It is triggered by a "sim://ramp" PV.
Whenever the value of that PV is greater than zero, the "text" property will be set to "Positive".
Whenever the value of that PV is less or equal than zero, the "text" property will be set to a
value that the user of that dialog was just about to enter as the screenshot was taken.
</p>

<p>Key features include:</p>
<ul>
  <li>Rule Name: Add and remove rules here. Select a rule to edit its properties.</li>
  <li>PVName: Add and remove input PVs for the rule. If "Trigger" is checked (true),
	  then the rule will execute whenever the PV's value changes.</li>
  <li>Property ID: The property which is affected by the rule.</li>
  <li>Boolean Expression: The expression which is evaluated when the rule executes. If it is
	  true, the property's value will be set to the expression's "Value" field. The expression may simply be
	  "true" or "True", in which case the value is always used (this is most useful when "Value as Expression"
	  is checked).
  </li>
  <li>Value: The value to use for the property if the boolean expression of that row is valid.
  </li>
</ul>

<h3>Boolean Expressions</h3>
<p>The standard comparison operators (&lt;, &gt;, ==, &lt;=, &gt;=, and !=) may be used. Logical
operators may also be used. All input PVs of the rule are accessible as follows:
</p>
<center>
	<table>
		<tr>
			<th>Value Type</th>
			<th>Syntax</th>
			<th>Example</th>
		</tr>
		<tr>
			<td>double value</td>
			<td><code>pv{index}</code></td>
			<td><code>pv0 > pv1</code></td>
		</tr>
		<tr>
			<td>long int. value</td>
			<td><code>pvInt{index}</code></td>
			<td><code>pvInt0 == 5</code></td>
		</tr>
		<tr>
			<td>alarm severity code</td>
			<td><code>pvSev{index}</code></td>
			<td><code>pvSev > 0</code></td>
		</tr>
        <tr>
            <td style="border-bottom: 0px">string value</td>
            <td style="border-bottom: 0px"><code>pvStr{index}</code></td>
            <td style="border-bottom: 0px"><code>pvStr0 == "happy"</code></td>
        </tr>
	</table>
</center>

<h3>Value as Expression</h3>
<p>
Assume a rule for the "width" property of a widget.
By default, the "Value" field provides the exact value, for example "40" for the width.
In Value-as-Expression mode, the value can contain an expression like "20 + pv0 * 2"
The expression will be evaluated by Python (Jython).
</p>

<h3>Value as Expression</h3>
<p>
Checking this option changes the way the "Value" is handled.
</p>
<p>
Assume a rule for the "width" property of a widget.
By default, the "Value" field provides the exact value, for example "40" for the width.
In Value-as-Expression mode, the value can contain an expression like "20 + pv0 * 2"
The expression will be evaluated by Python (Jython).
</p>

<h3>Show Script</h3>
<p>
Rules are internally translated into scripts, which are then executed.
The "Show Script" button allows previewing the the generated script,
which can help to understand or debug a rule.
</p>


<!-- ====================================================== -->
<h2><a name="scripts">Scripts</a></h2>
<!-- ====================================================== -->

<h3>Purpose</h3>

<p>Ideally, a control system display can be created by
simply adding several widgets and configuring their
properties. In many cases, only the location, size
and PV name of a widget needs to be configured.
</p>

<p>There are cases, however, where the built-in
widget functionality is not sufficient.
Traditionally, this would be handled by developing a custom,
site-specific user interface tool.
The display builder script support often allows you
to avoid the creation of such a custom tool.
</p>


<h3>Basic Functionality</h3>

<p>Scripts are invoked from
</p>

<ul>
<li>PV changes</li>
<li>Actions</li>
</ul>

<p>The script always receives the <code>widget</code> which invoked it.
A script associated with PVs also receives the <code>pvs</code>
which might have triggered its invocation.
</p>


<h3>PV Scripts</h3>

<p>Example of invoking a script from PV changes:
</p>

<ol>
<li>Create a Label widget</li>
<li>On its Scripts property, add a script by either specifying the path to the script,
    typically in a form relative to the location of the *.bob file,
    or enter the "embedded" script text.
</li>
<li>Add at least one PV. Enter its name, note that "Trigger" is by default selected.</li>
<li>You may add more PVs. Assert that at least one has the "Trigger" selected.</li>
</ol>

<p>At runtime, a connection is established to all PVs.
Whenever PVs marked as a "Trigger" change their value,
the script is invoked.
The script will receive a <code>widget</code> parameter
that holds the Label, and a <code>pvs</code> parameter
that holds a list of all PVs assigned to the script.
</p>

<p>A typical example is a script that reads the values of its PVs,
computes something, and uses the result to update one or more properties of the
widget:
</p>

<pre>
value = PVUtil.getDouble(pvs[0])
if value >= 0:
    result = "Positive"
else:
    result = "Negative"
widget.setPropertyValue("text", result)
</pre>

<h4>Disconnected PVs</h4>

<p>By default, a script is only executed whenever a "Trigger" PV has a new value
and all PVs are connected.
A script can therefore assume that all PVs have a value, but since PVs can disconnect
at any time, especially for a longer running script, it is possible that the value
of a PV is not defined.
This will typically result in a script that fails to execute because it tries to access
a Python <code>None</code> value.
The widget indicates to the user via its border that there is one or more disconnected PV,
which includes disconnected script PVs.
Once the PV reconnects, the script will again execute successfully.
</p>
<p>A careful Python script that needs to avoid <code>None</code> errors can check like this:
</p>

<pre>
value = pvs[0].read()
if value is None:
    widget.setPropertyValue("text", "Not connected")
else:
    widget.setPropertyValue("text", ValueUtil.getString(value))
</pre>

<p>By default, a script will thus rarely see any PVs in a disconnected state.
If a script actually needs to react to disconnect events,
the script option to "Only trigger when all PVs are connected"
can be de-selected in the script configuration dialog.
The script will now be invoked
</p>

<ul>
<li>Once when the display starts while most PVs are still likely disconnected.</li>
<li>Whenever a "Trigger" PV has a new value, which includes when the PV connects and receives its initial value.</li>
<li>Whenever a "Trigger" PV becomes disconnected.</li>
</ul>

<h3>Action Scripts</h3>

<p>Example of invoking a script from an Action:
</p>

<ol>
<li>Create an Action Button widget</li>
<li>On its Actions property, add an "Execute Script" action</li>
<li>Enter the path to the script, typically in a form relative to the location of the *.bob file,
    or enter the "embedded" script text.
</li>
</ol>

<p>At runtime, pushing the button will invoke the script.
The script receives a <code>widget</code> parameter
that holds the Action Button.
</p>

<p>A typical example is a script that performs some
action outside of the display tool,
then maybe displays the result in other widgets
which it locates based on their name:
</p>

<pre>
# 'widget' is the action button to which this script is attached
# If necessary, locate other widgets in the display by name:
from org.csstudio.display.builder.runtime.script import ScriptUtil
other = ScriptUtil.findWidgetByName(widget, "name_of_other_widget")

result = InvokeSomeCodeThatDoesSomething()

other.setPropertyValue("text", result)
</pre>


<h3>Jython Script</h3>

<p>Jython scripts are written in Python syntax, i.e. a very well designed, robust language.
They execute within the same Java instance that also executes the display builder
and have access to the complete API, including undocumented code.
</p>

<p>Any script file with a name that ends in ".py" which does not contain the word "python"
in its first line is executed as a Jython script.
In addition, the code of Jython scripts can be embedded in the *.bob file.
</p>

<p>As a downside, Jython scripts do not have access to the complete set of
native Python libraries, for example numpy.
</p>


<h3>Python Scripts</h3>

<p>Python scripts are executed by a native Python interpreter outside of the display builder.
They access key Display Builder API via networked proxies using Py4J.
Python scripts have access to all native Python libraries, for example numpy.
</p>

<p>Any script file with a name that ends in ".py" which contains the word "python"
in its first line is executed as a Python script.
This is typically accomplished via the usual Python shebang
</p>

<pre>
#!/usr/bin/env python
</pre>

<p>Python scripts must be in *.py files, they cannot be embedded in the *.bob file.
</p>

<p>As a downside, Python scripts incur some overhead at startup and whenever they
access the Display Builder API, because this is done via networked proxies.
They also depend on python being installed on the computer.
</p>

<p>To use native python scripts, python must be installed on the computer.
In addition, Py4J needs to be added if the invoked python code should
interact with the display. This is typically done via
</p>

<pre>
# For python 2.x
easy_install py4j
</pre>

<p>or</p>

<pre>
# For python 3.x
pip install py4j
</pre>


<p>For convenience, a Python module, <code>connect2j</code>, is provided with Display Builder; it implements a context
manager to manage the network connections and ensure that resources are properly released.
</p>

<p>To install <code>connect2j</code>, do the following:</p>
<ol>
<li>Under the CS-Studio installation directory, in "plugins/", locate the *.jar
    file beginning with "org.csstudio.display.builder.runtime"; that is, something
    like: <pre>org.csstudio.display.builder.runtime_1.0.0.201605162005.jar.</pre>
</li>

<li>Extract the "scripts" directory from the jar.
    <ul>
    <li>On a Unix system, you can use:
    <pre>unzip org.csstudio.display.builder.runtime_1.0.0.201605162005.jar scripts/*</pre>
    </li>
    <li>On any system with Java installed, you can use:
    <pre>jar xf org.csstudio.display.builder.runtime_1.0.0.201605162005.jar scripts/connect2j.py scripts/setup.py</pre>
    </li>
    </ul>
</li>

<li>Next, install the module:
    <pre>
cd scripts
python setup.py install
    </pre>
</li>

<li>The scripts directory which was created may now be deleted.</li>
</ol>

<p>The main API of <code>connect2j</code> is the scriptContext context manager. Simply place code which accesses
Display Builder API inside a "with" statement using scriptContext, like so:
</p>
<pre>#!/usr/bin/env python
from connect2j import scriptContext

# Code that does not interact with Display Builder

with scriptContext('widget', 'pvs', 'ScriptUtil', 'PVUtil', dict=globals()):
    # Code that uses DisplayBuilder APIs; for example:
    value = PVUtil.getDouble(pvs[0])

# Code that does not interact with Display Builder
</pre>

<p>Above, the argument "dict=globals()" tells scriptContext to enter the previous
arguments in the calling module's global dict, where they may be accessed as global
variables and used as typical Display Builder API. Without a dict argument supplied,
the appropriate entries are made in the <code>connect2j</code> module's global dict and must be
imported from <code>connect2j</code> <em>after the script context is created</em>. Any or all of
the string arguments may be omitted, and no variables or proxies will be created for the omitted arguments.
</p>

<p>As an additional convenience, <code>connect2j.scriptContext</code> may also be used in Jython code, which will
then be identical (except for the first line) to its corresponding Python code. Automatically, scriptContext
identifies the platform on which it is being run and chooses to either use Py4J to create proxies for its
arguments, or import the given utility classes and use the 'pvs' and 'widgets' which are already accessible from Jython.
</p>

<h3>Comparison: Python and Jython</h3>
<center>
	<table>
		<tr>
			<th></th>
			<th>Native Python</th>
			<th>Jython</th>
		</tr>
		<tr>
			<td><b>requirements</b></td>
			<td>*.py file, "python" first line (i.e. shebang)</td>
			<td>*.py (file or url) or embedded script</td>
		</tr>
		<tr>
			<td><b>API</b></td>
			<td>scriptContext (must be installed)
				<ul>
					<li>widget, pvs</li>
					<li>PVUtil</li>
					<li>ScriptUtil</li>
				</ul>
			</td>
			<td>scriptContext (added to path)
				<ul>
					<li>widget, pvs (accessible without context)</li>
					<li>PVUtil</li>
					<li>ScriptUtil</li>
				</ul>
			</td>
		</tr>
		<tr>
			<td><b>imports</b></td>
			<td>libraries (numPy, sciPy, etc.)</td>
			<td>Java classes (inc. PVUtil, ScriptUtil)</td>
		</tr>
		<tr>
			<td><b>start display</b></td>
			<td>no initial start time</td>
			<td>a few seconds to start Jython interpreter</td>
		</tr>
		<tr>
			<td style="border-bottom: 0px"><b>start script</b></td>
			<td style="border-bottom: 0px">about a second per script</td>
			<td style="border-bottom: 0px">virtually no start time per script</td>
		</tr>
	</table>
</center>

<h3>JavaScript Scripts</h3>

<p>Similar to Jython, JavaScript can be used as a language
with execution inside the Java instance that also runs the Display builder.
</p>

<p>Any script file with a name that ends in ".js" executed as JavaScript.
In addition, the JavaScript code can be embedded in the *.bob file.
</p>


<h3>Threading</h3>

<p>Each *.bob display has one script execution thread and one instance of the
Jython, Python and JavaScript support.
This allows scripts to run in the background without negatively impacting the user interface thread.
It also allows scripts for different *.bob displays to execute in parallel.
</p>

<p>
To limit the use of resources, however, at most <u>one</u> script executes for a given *.bob
display at a time.
Furthermore, if a specific script is triggered by either an action or a PV change,
further invocations of that same script are ignored until the current execution of the script finishes.
</p>


<h3>API</h3>

<p>For details refer to the <a href="#get_started">examples</a>
and the

<!-- The java/* docs are created by the javadoc.xml ANT script
     in combination with the javadoc_overview.html file
  -->
<a href="java/overview-summary.html">Java documentation</a>
</p>


</body>
</html>
